"use strict";
/**
 * TRIP CLASSIFIER HTTP FUNCTIONS
 * ==============================
 * HTTP callable functions to invoke the Python Stop-Go-Classifier.
 *
 * Auth: requireAuth (401 if missing/expired token); ownership enforced
 * so users can only classify their own trips (403 otherwise).
 *
 * The Python classifier is deployed as a separate Cloud Function (2nd gen).
 * This TypeScript function calls it after trip finalization to detect
 * stops and trip segments.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.batchClassifyTrips = exports.classifyTrip = void 0;
exports.classifyCompletedTrip = classifyCompletedTrip;
const functions = __importStar(require("firebase-functions"));
const admin = __importStar(require("firebase-admin"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const auth_1 = require("./auth");
const types_1 = require("../types");
const db = admin.firestore();
// Python classifier Cloud Function URL
// Set via Firebase environment config: firebase functions:config:set classifier.url="https://..."
const CLASSIFIER_URL = functions.config().classifier?.url || process.env.CLASSIFIER_URL;
/**
 * Convert TripPoints to classifier format
 */
function formatPointsForClassifier(points, startTimestampMs) {
    return points.map(point => ({
        lat: point.lat,
        lng: point.lng,
        ts: startTimestampMs + point.t, // Convert offset to absolute timestamp
        speed: point.spd / 100, // Convert back to m/s
    }));
}
/**
 * Call Python classifier Cloud Function
 */
async function callPythonClassifier(tripId, userId, points, settings) {
    if (!CLASSIFIER_URL) {
        functions.logger.warn('Classifier URL not configured, skipping classification');
        return {
            success: false,
            trip_id: tripId,
            error: 'Classifier URL not configured',
        };
    }
    try {
        const response = await (0, node_fetch_1.default)(`${CLASSIFIER_URL}/classify_trip`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                trip_id: tripId,
                user_id: userId,
                points,
                settings,
                save_results: false, // We'll save from TypeScript for consistency
            }),
        });
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Classifier returned ${response.status}: ${errorText}`);
        }
        return await response.json();
    }
    catch (error) {
        functions.logger.error(`Error calling classifier for trip ${tripId}:`, error);
        return {
            success: false,
            trip_id: tripId,
            error: error instanceof Error ? error.message : 'Unknown error',
        };
    }
}
/**
 * Save classification results to Firestore
 */
async function saveClassificationResults(tripId, userId, response) {
    if (!response.success || !response.classification) {
        functions.logger.warn(`No classification results to save for trip ${tripId}`);
        return;
    }
    const { classification } = response;
    // Transform stops
    const stops = classification.stops.map(stop => ({
        startTime: stop.start_time,
        endTime: stop.end_time,
        durationSeconds: stop.duration_seconds,
        centerX: stop.center_x,
        centerY: stop.center_y,
    }));
    // Transform trip segments
    const trips = classification.trips.map(trip => ({
        startTime: trip.start_time,
        endTime: trip.end_time,
        durationSeconds: trip.duration_seconds,
    }));
    // Transform summary
    const summary = {
        totalPoints: classification.summary.total_points,
        totalStops: classification.summary.total_stops,
        totalTrips: classification.summary.total_trips,
        classificationSuccess: classification.summary.classification_success,
        centerLat: classification.summary.center_lat,
        centerLng: classification.summary.center_lng,
        error: classification.summary.error,
    };
    // Create segmentation document
    const segmentDoc = {
        tripId,
        userId,
        stops,
        trips,
        summary,
        classifiedAt: admin.firestore.FieldValue.serverTimestamp(),
        classifierVersion: '1.0.0',
    };
    // Save to tripSegments collection
    const segmentsRef = db.collection('tripSegments').doc(tripId);
    await segmentsRef.set(segmentDoc);
    // Update trip document with segmentation summary
    const tripRef = db.collection(types_1.COLLECTION_NAMES.TRIPS).doc(tripId);
    await tripRef.update({
        segmentation: {
            totalStops: summary.totalStops,
            totalSegments: summary.totalTrips,
            classifiedAt: admin.firestore.FieldValue.serverTimestamp(),
            hasSignificantStops: summary.totalStops > 0,
        },
    });
    functions.logger.info(`Saved classification results for trip ${tripId}:`, {
        stops: stops.length,
        segments: trips.length,
    });
}
/**
 * Read trip points from Firestore
 */
async function readTripPoints(tripId) {
    const pointsRef = db.collection(types_1.COLLECTION_NAMES.TRIP_POINTS).doc(tripId);
    const snapshot = await pointsRef.get();
    if (!snapshot.exists) {
        functions.logger.warn(`No trip points found for trip ${tripId}`);
        return [];
    }
    const data = snapshot.data();
    // Check if points are in main document
    if (data.points && data.points.length > 0) {
        return data.points;
    }
    // Otherwise fetch from batches subcollection
    const batchesSnapshot = await pointsRef
        .collection('batches')
        .orderBy('batchIndex')
        .get();
    const allPoints = [];
    batchesSnapshot.docs.forEach(doc => {
        const batch = doc.data();
        if (batch.points && Array.isArray(batch.points)) {
            allPoints.push(...batch.points);
        }
    });
    return allPoints;
}
// ============================================================================
// HTTP CALLABLE FUNCTIONS
// ============================================================================
/**
 * Classify a completed trip
 *
 * Callable from client or other Cloud Functions to trigger classification
 * for a specific trip. User can only classify their own trips (trip.userId
 * must equal auth.uid).
 *
 * @param data.tripId - The trip ID to classify
 * @returns Classification results
 */
exports.classifyTrip = functions.https.onCall(async (data, context) => {
    const userId = (0, auth_1.requireAuth)(context);
    // TODO: Rate limiting – e.g. max N classifyTrip calls per user per minute
    // Example: Firestore/Redis counter keyed by userId, reject if over threshold
    const tripId = data?.tripId;
    if (typeof tripId !== 'string' || tripId.trim() === '') {
        throw new functions.https.HttpsError('invalid-argument', 'tripId is required');
    }
    functions.logger.info(`Classifying trip ${tripId} requested by user ${userId}`);
    try {
        const tripRef = db.collection(types_1.COLLECTION_NAMES.TRIPS).doc(tripId);
        const tripDoc = await tripRef.get();
        if (!tripDoc.exists) {
            throw new functions.https.HttpsError('not-found', `Trip ${tripId} not found`);
        }
        const trip = tripDoc.data();
        // Authorization: user can only classify their own trips (403 if not owner)
        if (trip.userId !== userId) {
            throw new functions.https.HttpsError('permission-denied', 'You can only classify your own trips');
        }
        // Only classify completed trips
        if (trip.status !== 'completed') {
            throw new functions.https.HttpsError('failed-precondition', `Trip must be completed to classify. Current status: ${trip.status}`);
        }
        // Read GPS points
        const points = await readTripPoints(tripId);
        if (points.length < 2) {
            throw new functions.https.HttpsError('failed-precondition', 'Trip has insufficient GPS points for classification');
        }
        // Format points and call classifier
        const formattedPoints = formatPointsForClassifier(points, trip.startedAt.toMillis());
        const classifierResponse = await callPythonClassifier(tripId, trip.userId, formattedPoints);
        // Save results if successful
        if (classifierResponse.success) {
            await saveClassificationResults(tripId, trip.userId, classifierResponse);
        }
        return {
            success: classifierResponse.success,
            tripId,
            summary: classifierResponse.classification?.summary,
            error: classifierResponse.error,
        };
    }
    catch (error) {
        functions.logger.error(`Error classifying trip ${tripId}:`, error);
        if (error instanceof functions.https.HttpsError) {
            throw error;
        }
        // Expired token: requireAuth() already throws unauthenticated with sign-in-again message
        throw new functions.https.HttpsError('internal', error instanceof Error ? error.message : 'Classification failed');
    }
});
/**
 * Batch classify multiple trips
 *
 * Admin-only. Reject unauthenticated with 401, non-admin with 403.
 */
exports.batchClassifyTrips = functions.https.onCall(async (data, context) => {
    (0, auth_1.requireAuth)(context);
    (0, auth_1.requireAdmin)(context);
    // TODO: Rate limiting – e.g. max 1 batch job per admin per 5 minutes
    // Example: check last batchClassifyTrips timestamp in Firestore/Redis for context.auth.uid
    const { tripIds, userId, limit = 10 } = data;
    let tripsToProcess = [];
    if (tripIds && Array.isArray(tripIds)) {
        tripsToProcess = tripIds.slice(0, limit);
    }
    else if (userId) {
        // Get recent completed trips for user
        const tripsSnapshot = await db
            .collection(types_1.COLLECTION_NAMES.TRIPS)
            .where('userId', '==', userId)
            .where('status', '==', 'completed')
            .orderBy('startedAt', 'desc')
            .limit(limit)
            .get();
        tripsToProcess = tripsSnapshot.docs.map(doc => doc.id);
    }
    functions.logger.info(`Batch classifying ${tripsToProcess.length} trips`);
    const results = await Promise.allSettled(tripsToProcess.map(async (tripId) => {
        const tripDoc = await db.collection(types_1.COLLECTION_NAMES.TRIPS).doc(tripId).get();
        if (!tripDoc.exists)
            return { tripId, status: 'not_found' };
        const trip = tripDoc.data();
        const points = await readTripPoints(tripId);
        if (points.length < 2) {
            return { tripId, status: 'insufficient_points' };
        }
        const formattedPoints = formatPointsForClassifier(points, trip.startedAt.toMillis());
        const response = await callPythonClassifier(tripId, trip.userId, formattedPoints);
        if (response.success) {
            await saveClassificationResults(tripId, trip.userId, response);
            return { tripId, status: 'classified', summary: response.classification?.summary };
        }
        return { tripId, status: 'failed', error: response.error };
    }));
    return {
        processed: results.length,
        results: results.map((r, i) => (r.status === 'fulfilled'
            ? r.value
            : { tripId: tripsToProcess[i], status: 'error', error: String(r.reason) })),
    };
});
// ============================================================================
// INTERNAL FUNCTIONS (called from trip triggers)
// ============================================================================
/**
 * Classify trip after completion
 *
 * Called from trip triggers when a trip transitions to 'completed'.
 * This is the main entry point for automatic classification.
 */
async function classifyCompletedTrip(tripId, trip) {
    functions.logger.info(`Auto-classifying completed trip ${tripId}`);
    try {
        // Read GPS points
        const points = await readTripPoints(tripId);
        if (points.length < 23) { // Minimum required by classifier
            functions.logger.warn(`Trip ${tripId} has only ${points.length} points, skipping classification`);
            return;
        }
        // Format points and call classifier
        const formattedPoints = formatPointsForClassifier(points, trip.startedAt.toMillis());
        // Use conservative settings for automatic classification
        const settings = {
            MIN_STOP_INTERVAL: 60, // 1 minute minimum stop
            MIN_DISTANCE_BETWEEN_STOP: 50, // 50 meters
        };
        const classifierResponse = await callPythonClassifier(tripId, trip.userId, formattedPoints, settings);
        // Save results if successful
        if (classifierResponse.success) {
            await saveClassificationResults(tripId, trip.userId, classifierResponse);
            functions.logger.info(`Trip ${tripId} classified successfully:`, {
                stops: classifierResponse.classification?.summary.total_stops,
                segments: classifierResponse.classification?.summary.total_trips,
            });
        }
        else {
            functions.logger.warn(`Classification failed for trip ${tripId}:`, classifierResponse.error);
        }
    }
    catch (error) {
        // Don't throw - classification is enhancement, not critical
        functions.logger.error(`Error auto-classifying trip ${tripId}:`, error);
    }
}
//# sourceMappingURL=classifier.js.map